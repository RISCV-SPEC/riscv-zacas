[[chapter2]]
== Word/Doubleword/Quadword CAS (AMOCAS.W/D/Q)

[wavedrom, , ] 
.... 
{reg: [
  {bits:  7, name: 'opcode', attr:'AMO'},
  {bits:  5, name: 'rd', attr:'dest'},
  {bits:  3, name: 'funct3', attr:['010', '011', '100']},
  {bits:  5, name: 'rs1', attr:'addr'},
  {bits:  5, name: 'rs2', attr:'src'},
  {bits:  1, name: 'rl'},
  {bits:  1, name: 'aq'},
  {bits:  5, name: '00101', attr:['AMOCAS.W', 'AMOCAS.D', 'AMOCAS.Q']},
], config:{lanes: 1, hspace:1024}}
....

For RV32, `AMOCAS.W` atomically loads a 32-bit data value from address in `rs1`,
compares the loaded value to the 32-bit value held in `rd` and if the comparison
is bitwise equal, then stores the 32-bit value held in `rs2` to the original
address in `rs1`. The value loaded from memory is placed into register `rd`. The
operation performed by `AMOCAS.W` for RV32 is as follows:

[listing]
----
    temp = mem[X(rs1)]
    if ( temp == X(rd) )
        mem[X(rs1)] = X(rs2)
    endif
    X(rd) = temp
----

For RV64, `AMOCAS.W` atomically loads a 32-bit data value from address in
`rs1`, compares the loaded value to the lower 32 bits of the value held in `rd`
and if the comparison is bitwise equal, then stores the lower 32 bits of the
value held in `rs2` to the original address in `rs1`. The 32-bit value loaded
from memory is sign extended and is placed into register `rd`. The operation
performed by `AMOCAS.W` for RV64 is as follows:

[listing]
----
    temp[31:0] = mem[X(rs1)]
    if ( temp[31:0] == X(rd)[31:0] )
        mem[X(rs1)] = X(rs2)[31:0]
    endif
    X(rd) = SignExtend(temp[31:0])
----

`AMOCAS.D` is similar to `AMOCAS.W` but operates on 64-bit data values.

For RV32, `AMOCAS.D` atomically loads 64-bits of a data value from address in
`rs1`, compares the loaded value to a 64-bit value held in a register pair
consisting of `rd` and `rd+1` and if the comparison is bitwise equal, then
stores the 64-bit value held in the register pair `rs2` and `rs2+1` to the
original address in `rs1`. The value loaded from memory is placed into the
register pair `rd` and `rd+1`. The instruction requires the first register in
the pair to be even numbered; encodings with odd numbered registers specified
in `rs2` and `rd` are reserved. When the first register of a source register
pair is `x0`, then both halves of the pair read as zero. When the first
register of a destination register pair is `x0`, then the entire register
result is discarded and neither destination register is written.
The operation performed by `AMOCAS.D` for RV32 is as follows:
[listing]
----
    temp0 = mem[X(rs1)+0]
    temp1 = mem[X(rs1)+4]
    comp0 = (rd == x0)  ? 0 : X(rd)
    comp1 = (rd == x0)  ? 0 : X(rd+1)
    swap0 = (rs2 == x0) ? 0 : X(rs2)
    swap1 = (rs2 == x0) ? 0 : X(rs2+1)
    if ( temp0 == comp0 ) && ( temp1 == comp1 )
        mem[X(rs1)+0] = swap0
        mem[X(rs1)+4] = swap1
    endif
    if ( rd != x0 )
        X(rd)   = temp0
        X(rd+1) = temp1
    endif
----

For RV64, `AMOCAS.D` atomically loads 64-bits of a data value from address in
`rs1`, compares the loaded value to a 64-bit value held in `rd` and if the
comparison is bitwise equal, then stores the 64-bit value held in `rs2` to the
original address in `rs1`. The value loaded from memory is placed into register
`rd`. The operation performed by `AMOCAS.D` for RV64 is as follows:
[listing]
----
    temp = mem[X(rs1)]
    if ( temp == X(rd) )
        mem[X(rs1)] = X(rs2)
    endif
    X(rd) = temp
----
`AMOCAS.Q` (RV64 only) atomically loads 128-bits of a data value from address in
`rs1`, compares the loaded value to a 128-bit value held in a register pair
consisting of `rd` and `rd+1` and if the comparison is bitwise equal, then
stores the 128-bit value held in the register pair `rs2` and `rs2+1` to the
original address in `rs1`. The value loaded from memory is placed into the
register pair `rd` and `rd+1`. The instruction requires the first register in
the pair to be even numbered; encodings with odd numbered registers specified in
`rs2` and `rd` are reserved. When the first register of a source register pair
is `x0`, then both halves of the pair read as zero. When the first register of a
destination register pair is `x0`, then the entire register result is discarded
and neither destination register is written. The operation performed by
`AMOCAS.Q` is as follows:
[listing]
----
    temp0 = mem[X(rs1)+0]
    temp1 = mem[X(rs1)+8]
    comp0 = (rd == x0)  ? 0 : X(rd)
    comp1 = (rd == x0)  ? 0 : X(rd+1)
    swap0 = (rs2 == x0) ? 0 : X(rs2)
    swap1 = (rs2 == x0) ? 0 : X(rs2+1)
    if ( temp0 == comp0 ) && ( temp1 == comp1 )
        mem[X(rs1)+0] = swap0
        mem[X(rs1)+8] = swap1
    endif
    if ( rd != x0 )
        X(rd)   = temp0
        X(rd+1) = temp1
    endif
----
[NOTE]
====
For a future RV128 extension, `AMOCAS.Q` would encode a single XLEN=128 register
in `rs2` and `rd`.
====
Just as for AMOs in the A extension, `AMOCAS.W/D/Q` requires that the address
held in `rs1` be naturally aligned to the size of the operand (i.e., 16-byte
aligned for _quadwords_, eight-byte aligned for _doublewords_, and four-byte
aligned for _words_). And the same exception options apply if the address
is not naturally aligned.

Just as for AMOs in the A extension, the `AMOCAS.W/D/Q` optionally provide
release consistency semantics, using the `aq` and `rl` bits, to help implement
multiprocessor synchronization.

[NOTE]
====
Some algorithms may load the previous data value of a memory location into the
register used as the compare data value source by a Zacas instruction. When
using a Zacas instruction that uses a register pair to source the compare value,
the two registers may be loaded using two individual loads. The two individual
loads may read an inconsistent pair of values but that is not an issue since the
`AMOCAS` operation itself uses an atomic load-pair from memory to obtain the
data value for its comparison.
=======

The following code sequence illustrates a quadword compare-and-swap operation.
The registers a6 and a7 that are used to source the compare data value are
loaded using two individual loads. The registers a4 and a5 hold the swap data
value. The register a0 holds the address of the memory location operated on by
the instruction.

[listing]
----
    # initialize the swap value
    li a4, new_value0
    li a5, new_value1

    # initialize the expected value
    li a2, expected_value0
    li a3, expected_value1

retry:
    # load the current value
    ld a6, 0(a0)
    ld a7, 8(a0)

    # retry if current value not the expected value
    bne a6, a2, retry
    bne a7, a3, retry

    # quadword compare and swap
    amocas.q.aqrl a6, a4, (a0)

    # retry if CAS failed
    bne a6, a2, retry
    bne a7, a3, retry
----

====

== Additional AMO PMAs

There are four levels of PMA support defined for AMOs in the A extension. Zacas
defines three additional levels of support: `AMOCASW`, `AMOCASD`, and `AMOCASQ`.

`AMOCASW` indicates that in addition to instructions indicated by `AMOArithmetic`
level support, the `AMOCAS.W` instruction is supported. `AMOCASD` indicates that
in addition to instructions indicated by `AMOCASW` level support, the `AMOCAS.D`
instruction is supported. `AMOCASQ` indicates that all RISC-V AMOs are supported.

[NOTE]
====
`AMOCASW/D/Q` require `AMOArithmetic` level support as the `AMOCAS.W/D/Q`
instructions require ability to perform an arithmetic comparison and a swap
operation. 
====

